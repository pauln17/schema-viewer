// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                   String                @id @default(uuid())
  email                String                @unique
  name                 String?
  role                 Role                  @default(USER)
  schemas              Schema[]
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  emailVerified        Boolean               @default(false)
  image                String?
  sessions             Session[]
  accounts             Account[]
  schemaCollaborations SchemaCollaboration[]

  @@map("user")
}

model Schema {
  id                   String                @id @default(uuid())
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  name                 String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  schemaTables         SchemaTable[]
  schemaCollaborations SchemaCollaboration[]

  @@index([userId])
  @@map("schema")
}

model SchemaCollaboration {
  id             String           @id @default(uuid())
  schema         Schema           @relation(fields: [schemaId], references: [id], onDelete: Cascade)
  schemaId       String
  user           User             @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)
  collaboratorId String
  role           CollaboratorRole @default(VIEWER)

  @@unique([schemaId, collaboratorId])
  @@index([collaboratorId])
  @@map("schema-collaboration")
}

model SchemaTable {
  id       String @id @default(uuid())
  schema   Schema @relation(fields: [schemaId], references: [id])
  schemaId String

  name String

  // Stored Table Position (Initially Auto Layout)
  positionX Float?
  positionY Float?

  tableColumns           TableColumn[]
  tableIndexs            TableIndex[]
  tableColumnConstraints TableColumnConstraint[]

  @@index([schemaId])
  @@map("schema-table")
}

model TableColumn {
  id            String      @id @default(uuid())
  schemaTable   SchemaTable @relation(fields: [schemaTableId], references: [id], onDelete: Cascade)
  schemaTableId String

  name     String
  dataType String // actual database type
  order    Int    @default(0) // controls vertical order inside table

  // Relations
  outgoingReferences ColumnRelation[] @relation("SourceColumn")
  incomingReferences ColumnRelation[] @relation("TargetColumn")

  // Constraints (PK, UNIQUE, NOT NULL, DEFAULT, CHECK, FK)
  tableColumnConstraints TableColumnConstraint[]

  @@index([schemaTableId])
  @@map("table-column")
}

model ColumnRelation {
  id             String      @id @default(uuid())
  sourceColumn   TableColumn @relation("SourceColumn", fields: [sourceColumnId], references: [id])
  sourceColumnId String
  targetColumn   TableColumn @relation("TargetColumn", fields: [targetColumnId], references: [id])
  targetColumnId String

  onDelete String? // "CASCADE", "SET NULL", "RESTRICT", etc.
  onUpdate String? // "CASCADE", "SET NULL", "RESTRICT", etc.

  @@index([sourceColumnId])
  @@index([targetColumnId])
  @@map("column-relation")
}

model TableIndex {
  id            String      @id @default(uuid())
  schemaTable   SchemaTable @relation(fields: [schemaTableId], references: [id], onDelete: Cascade)
  schemaTableId String

  name             String
  indexedColumnIds String[] // Ordered Column Names

  @@index([schemaTableId])
  @@map("table-index")
}

model TableColumnConstraint {
  id            String       @id @default(uuid())
  schemaTable   SchemaTable  @relation(fields: [schemaTableId], references: [id], onDelete: Cascade)
  schemaTableId String
  tableColumn   TableColumn? @relation(fields: [tableColumnId], references: [id])
  tableColumnId String?

  type       ConstraintType
  expression String? // Raw SQL Condition (Check), Optional for PK, FK, NOT NULL

  @@index([schemaTableId])
  @@map("table-column-constraint")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

enum Role {
  USER
  ADMIN
}

enum CollaboratorRole {
  VIEWER
  EDITOR
}

enum ConstraintType {
  PRIMARY_KEY
  FOREIGN_KEY
  DEFAULT
  UNIQUE
  CHECK
  NOT_NULL
}
